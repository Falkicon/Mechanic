"""
Lua Eval Queue Commands for Mechanic Desktop.

Provides round-trip Lua execution:
- lua.queue: Queue Lua code for in-game execution
- lua.results: Read results from last eval (via addon.output)

Workflow:
1. Agent calls `lua.queue` with code snippets
2. User does /reload in WoW
3. Addon executes code and stores results
4. Agent reads results via `addon.output` or `lua.results`
"""

from pathlib import Path
from typing import Any, Dict, List, Optional
from datetime import datetime

from afd import CommandResult, success, error
from afd.core.metadata import create_source
from pydantic import BaseModel, Field


# ═══════════════════════════════════════════════════════════════════════════════
# SCHEMAS
# ═══════════════════════════════════════════════════════════════════════════════

class LuaQueueInput(BaseModel):
    code: List[str] = Field(
        ..., 
        description="List of Lua code snippets to execute. Each snippet should return a value."
    )
    labels: Optional[List[str]] = Field(
        None, 
        description="Optional labels for each snippet (for easier identification in results)"
    )


class LuaQueueResult(BaseModel):
    queued: int
    queue_file: str
    snippets: List[str]
    message: str


class LuaResultsInput(BaseModel):
    pass  # No input needed


class LuaResultsResult(BaseModel):
    results: List[Dict[str, Any]]
    total: int
    last_run: Optional[str]


# ═══════════════════════════════════════════════════════════════════════════════
# HELPERS
# ═══════════════════════════════════════════════════════════════════════════════

def find_addon_path() -> Optional[Path]:
    """Find the !Mechanic addon folder (where we can write queue files)."""
    from ..config import discover_saved_variables
    
    paths = discover_saved_variables()
    if not paths:
        return None
    
    # Find the most recently modified !Mechanic.lua, then derive addon path
    best_path = None
    best_mtime = 0
    
    for sv_dir in paths:
        mechanic_lua = sv_dir / "!Mechanic.lua"
        if mechanic_lua.exists():
            mtime = mechanic_lua.stat().st_mtime
            if mtime > best_mtime:
                best_mtime = mtime
                # sv_dir is like: _beta_/WTF/Account/XXX/SavedVariables
                # Go up 4 levels to get to _beta_, then down to Interface/AddOns
                wow_client = sv_dir.parent.parent.parent.parent
                addon_path = wow_client / "Interface" / "AddOns" / "!Mechanic"
                if addon_path.exists():
                    best_path = addon_path
    
    return best_path


def escape_lua_string(s: str) -> str:
    """Escape a string for Lua long string format."""
    # Use Lua long string format [[ ]] which doesn't need escaping
    # But we need to handle nested brackets
    level = 0
    while f"]{('=' * level)}]" in s or f"[{('=' * level)}[" in s:
        level += 1
    return f"[{'=' * level}[{s}]{'=' * level}]"


def write_lua_queue_file(snippets: List[str], labels: Optional[List[str]] = None) -> Optional[Path]:
    """
    Write the Lua eval queue to MechanicQueue.lua.
    
    Completely rewrites the file (both API and Lua queues are written fresh).
    """
    addon_path = find_addon_path()
    if not addon_path:
        return None
    
    queue_file = addon_path / "MechanicQueue.lua"
    
    # Build the Lua table for the queue
    queue_items = []
    for i, code in enumerate(snippets):
        label = labels[i] if labels and i < len(labels) else f"snippet_{i+1}"
        escaped_code = escape_lua_string(code)
        queue_items.append(f'\t{{\n\t\t["label"] = "{label}",\n\t\t["code"] = {escaped_code},\n\t}}')
    
    queue_lua = "{\n" + ",\n".join(queue_items) + "\n}"
    
    # Always write fresh - don't try to preserve old content
    content = f"""-- Auto-generated by Mechanic Desktop CLI
-- This file is read by Mechanic on addon load
-- Do not edit manually

MECHANIC_LUA_QUEUE = {queue_lua}
"""
    
    queue_file.write_text(content, encoding="utf-8")
    return queue_file


def get_lua_results() -> Dict[str, Any]:
    """Read Lua eval results from MechanicDB SavedVariables."""
    from ..config import discover_saved_variables
    from ..parsers import parse_savedvariables
    
    sv_paths = discover_saved_variables()
    
    for sv_path in sv_paths:
        mechanic_file = sv_path / "!Mechanic.lua"
        if mechanic_file.exists():
            try:
                content = mechanic_file.read_text(encoding="utf-8", errors="replace")
                variables = parse_savedvariables(content)
                db = variables.get("MechanicDB", {})
                profiles = db.get("profiles", {})
                if profiles:
                    profile_data = profiles.get("Default", {})
                    return profile_data.get("luaEvalResults", {})
            except Exception:
                pass
    
    return {}


# ═══════════════════════════════════════════════════════════════════════════════
# COMMANDS
# ═══════════════════════════════════════════════════════════════════════════════

def register_commands(server):
    """Register Lua eval commands with the server."""
    
    @server.command(
        name="lua.queue",
        description="Queue Lua code snippets for in-game execution. After running this, /reload in WoW to execute.",
        input_schema=LuaQueueInput,
        output_schema=LuaQueueResult,
    )
    async def lua_queue(input: LuaQueueInput, context: Any = None) -> CommandResult[LuaQueueResult]:
        if not input.code:
            return error(
                code="NO_CODE",
                message="No code snippets provided",
                suggestion="Provide at least one Lua code snippet"
            )
        
        # Validate labels count matches if provided
        if input.labels and len(input.labels) != len(input.code):
            return error(
                code="LABEL_MISMATCH",
                message=f"Labels count ({len(input.labels)}) doesn't match code count ({len(input.code)})",
                suggestion="Provide one label per code snippet, or omit labels"
            )
        
        # Write to queue file
        queue_path = write_lua_queue_file(input.code, input.labels)
        
        if not queue_path:
            return error(
                code="ADDON_NOT_FOUND",
                message="Could not find !Mechanic addon folder",
                suggestion="Ensure !Mechanic is installed in Interface/AddOns"
            )
        
        # Generate preview of snippets
        previews = []
        for i, code in enumerate(input.code):
            label = input.labels[i] if input.labels else f"snippet_{i+1}"
            preview = code[:50] + "..." if len(code) > 50 else code
            previews.append(f"{label}: {preview}")
        
        return success(
            data=LuaQueueResult(
                queued=len(input.code),
                queue_file=str(queue_path),
                snippets=previews,
                message=f"Queued {len(input.code)} Lua snippet(s). /reload in WoW to execute."
            ),
            reasoning=f"Wrote {len(input.code)} Lua snippets to {queue_path.name}"
        )
    
    @server.command(
        name="lua.results",
        description="Get results from the last Lua eval queue execution",
        input_schema=LuaResultsInput,
        output_schema=LuaResultsResult,
    )
    async def lua_results(input: LuaResultsInput, context: Any = None) -> CommandResult[LuaResultsResult]:
        results_data = get_lua_results()
        
        if not results_data:
            return success(
                data=LuaResultsResult(results=[], total=0, last_run=None),
                reasoning="No Lua eval results found. Queue some code with lua.queue, then /reload in WoW."
            )
        
        results = results_data.get("results", [])
        last_run = results_data.get("lastRun")
        
        src = create_source(
            type="file",
            id="mechanic-db",
            title="MechanicDB Lua Results"
        )
        
        return success(
            data=LuaResultsResult(
                results=results if isinstance(results, list) else list(results.values()),
                total=len(results) if isinstance(results, (list, dict)) else 0,
                last_run=last_run
            ),
            reasoning=f"Found {len(results)} Lua eval results from {last_run or 'unknown time'}",
            sources=[src]
        )
